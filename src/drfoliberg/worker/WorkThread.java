package drfoliberg.worker;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.attribute.PosixFilePermission;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.apache.commons.io.FileUtils;

import drfoliberg.common.Service;
import drfoliberg.common.exceptions.MissingDecoderException;
import drfoliberg.common.exceptions.MissingFfmpegException;
import drfoliberg.common.exceptions.WorkInterruptedException;
import drfoliberg.common.network.Cause;
import drfoliberg.common.network.messages.cluster.CrashReport;
import drfoliberg.common.status.NodeState;
import drfoliberg.common.task.Task;

public class WorkThread extends Service {

	private Task task;
	private Worker callback;
	Process process;

	File taskFinalFolder;
	File absoluteSharedDir;
	File taskTempOutputFile;
	File taskTempOutputFolder;

	public WorkThread(Worker w, Task t) {
		task = t;
		callback = w;
		callback.getCurrentTask().start();
	}

	private void createDirs() {
		if (!taskFinalFolder.exists()) {
			taskFinalFolder.mkdirs();
			givePerms(taskFinalFolder);
		}
		taskTempOutputFolder = FileUtils.getFile(callback.config.getTempEncodingFolder(), task.getJobId(),
				String.valueOf(task.getTaskId()));
		if (!taskTempOutputFolder.exists()) {
			taskTempOutputFolder.mkdirs();
			givePerms(taskTempOutputFolder);
		}
		// remove any previous temp files for this part
		cleanTempPart();
		String extension = "mkv";
		String filename = String.format("%d.%s", task.getTaskId(), extension);
		taskTempOutputFile = new File(taskTempOutputFolder, filename);
	}

	/**
	 * Convert ms count to hh:mm:ss.xxx format
	 * 
	 * @param ms
	 *            The ms count to convert
	 * @return The string in the right format for ffmpeg/libav
	 */
	private String getDurationString(long ms) {
		int hours = (int) (ms / (3600 * 1000));
		int remaining = (int) (ms - hours * 3600 * 1000);
		int minutes = (int) (remaining / (60 * 1000));

		remaining -= minutes * 60 * 1000;

		int seconds = remaining / 1000;
		int decimals = remaining % 1000;
		return String.format("%d:%d:%d.%d", hours, minutes, seconds, decimals);
	}

	public void encodePass(String startTimeStr, String durationStr) throws MissingFfmpegException,
			MissingDecoderException, WorkInterruptedException {

		absoluteSharedDir = new File(callback.config.getAbsoluteSharedFolder());
		task.setTimeStarted(System.currentTimeMillis());

		File inputFile = new File(absoluteSharedDir, task.getSourceFile());

		// Get parameters from the task and bind parameters to process
		try {
			String[] baseArgs = new String[] { "ffmpeg", "-ss", startTimeStr, "-t", durationStr, "-i",
					inputFile.getAbsolutePath(), "-sn", "-force_key_frames", "0", "-an", "-c:v", "libx264" };
			ArrayList<String> ffmpegArgs = new ArrayList<>();
			// Add base args to process builder
			for (String arg : baseArgs) {
				ffmpegArgs.add(arg);
			}

			ffmpegArgs.addAll(task.getRateControlArgs());
			ffmpegArgs.addAll(task.getPresetArg());

			String outFile = taskTempOutputFile.getAbsoluteFile().toString();

			if (task.getPasses() > 1) {
				// Add pass arguments
				ffmpegArgs.add("-pass");
				ffmpegArgs.add(String.valueOf(task.getCurrentPass()));
				if (task.getCurrentPass() != task.getPasses()) {
					ffmpegArgs.add("-f");
					ffmpegArgs.add("rawvideo");
					ffmpegArgs.add("-y");
					// Change output file to null
					outFile = "/dev/null"; // TODO use NUL for windows
				}
			}
			// Add output file
			ffmpegArgs.add(outFile);

			ProcessBuilder pb = new ProcessBuilder(ffmpegArgs);
			System.out.println(pb.command().toString());

			// Start process in task output directory (log and mtrees pass files generated by ffmpeg)
			pb.directory(taskTempOutputFolder);
			process = pb.start();

		} catch (IOException e) {
			e.printStackTrace();
			throw new MissingFfmpegException();
		}

		// Read from ffmpeg stderr to get progress
		InputStream stderr = process.getErrorStream();
		Scanner s = new Scanner(stderr);
		String line = "";

		Pattern currentFramePattern = Pattern.compile("frame=\\s*([0-9]*)");
		Pattern fpsPattern = Pattern.compile("fps=\\s*([0-9]*)");
		Pattern missingDecoder = Pattern.compile("Error while opening encoder for output stream");
		try {
			while (s.hasNext() && !close) {
				// TODO better scanning (avoid regexing the same line multiple times if result)

				line = s.nextLine();
				Matcher m = currentFramePattern.matcher(line);

				if (m.find()) {
					long currentFrame = Long.parseLong(m.group(1));
					callback.getCurrentTask().setFramesCompleted(currentFrame);

					System.err.printf("frame: %d out of %d (%f%%) \n", currentFrame, task.getEstimatedFramesCount(),
							callback.getCurrentTask().getProgress());
				}
				m = fpsPattern.matcher(line);
				if (m.find()) {
					float fps = Float.parseFloat(m.group(1));
					callback.getCurrentTask().setFps(fps);
					System.err.printf("fps: %s \n", fps);
				}
				m = missingDecoder.matcher(line);
				if (m.find()) {
					s.close();
					System.err.println("Missing decoder !");
					throw new MissingDecoderException();
				}

			}
		} catch (NullPointerException e) {
			// If task is interrupted, current task might become null
			if (!close) {
				// If thread is not stopped and a null pointer occurs, it is not normal
				e.printStackTrace();
				close = true;
			}
		}
		s.close();

		if (close) {
			System.err.println("Destroying ffmpeg process");
			process.destroy();
			throw new WorkInterruptedException();
		}
	}

	@Override
	public void run() {
		try {
			System.out.println("WORKER WORK THREAD: Executing a task!");
			// use start and duration for ffmpeg legacy support
			long durationMs = task.getEncodingEndTime() - task.getEncodingStartTime();
			String startTimeStr = getDurationString(task.getEncodingStartTime());
			String durationStr = getDurationString(durationMs);

			this.taskFinalFolder = FileUtils.getFile(callback.config.getAbsoluteSharedFolder(), task.getOutputFile())
					.getParentFile();

			createDirs();

			task.setCurrentPass((byte) 1);
			while (task.getCurrentPass() <= task.getPasses()) {
				System.err.printf("Encoding pass %d of %d\n", task.getCurrentPass(), task.getPasses());
				encodePass(startTimeStr, durationStr);
				task.setCurrentPass((byte) (task.getCurrentPass() + 1));
			}

			moveTempPartFile();
			cleanTempPart();
			callback.taskDone(task);

		} catch (MissingFfmpegException e) {
			CrashReport report = new CrashReport(callback.config.getUniqueID(), new Cause(e, "", true),
					callback.getStatusReport());
			callback.sendCrashReport(report);
			// update status
			callback.updateStatus(NodeState.CRASHED);
		} catch (MissingDecoderException e) {
			e.printStackTrace();
		} catch (WorkInterruptedException e) {
			System.err.println("WORKER: stopping work");
			cleanTempPart();
		}
	}

	private void cleanTempPart() {
		System.out.println("WORKER: Deleting temp task folder");
		if (taskTempOutputFolder.exists()) {
			try {
				FileUtils.cleanDirectory(taskTempOutputFolder);
			} catch (IOException e) {
				e.printStackTrace();
			}
		}
	}

	private void moveTempPartFile() {
		// TODO check if file already exists at destination and delete ?
		System.out.println("WORKER: Moving temp file to shared folder");
		try {
			//FileUtils.moveFileToDirectory(taskTempOutputFile, taskFinalFolder, true);
			FileUtils.moveFile(taskTempOutputFile, new File(absoluteSharedDir, task.getOutputFile()));
		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	private static void givePerms(File f) {
		try {
			Path p = Paths.get(f.toURI());
			Set<PosixFilePermission> perms = Files.getPosixFilePermissions(p);
			perms.add(PosixFilePermission.OWNER_READ);
			perms.add(PosixFilePermission.OWNER_WRITE);
			perms.add(PosixFilePermission.OWNER_EXECUTE);
			perms.add(PosixFilePermission.GROUP_READ);
			perms.add(PosixFilePermission.GROUP_WRITE);
			perms.add(PosixFilePermission.GROUP_EXECUTE);
			perms.add(PosixFilePermission.OTHERS_READ);
			perms.add(PosixFilePermission.OTHERS_WRITE);
			perms.add(PosixFilePermission.OTHERS_EXECUTE);
			Files.setPosixFilePermissions(p, perms);
		} catch (IOException e) {
			System.err.printf("Could not set group writable to %s\n", f.toString());
		}
	}
}
